# Matrices and vectors in STACK.

## Matrices ##

Note that in Maxima, matrix multiplication is the dot, e.g.
`A.B`.  The star `A*B` gives element-wise multiplication.

The paper
[Setting Linear Algebra Problems](http://web.maths.unsw.edu.au/~jds/Papers/linalg.pdf)
is rather interesting.

The following functions are part of Maxima, but are very useful for us.

    rowswap(m,i,j)
    addrow(m,i,j,k)

Where ` m[i]: m[i] + k * m[j]`.

    rowmul(m,i,k)

Where `m[i]: k * m[i]`.
And a function to compute reduced row echelon form

    rref(m)

## Assigning individual elements ##

To assign values to individual elements, use the simple syntax such as the following.

    m:matrix([1,1],[1,2])
    m[1,2]:3

### Showing working {#Showing_working}

It is quite common to want to show part of a matrix calculation "un-evaluated".  For example, the following is typical.

\[ \left[\begin{array}{cc} 1 & 2 \\ 4 & 5 \\ \end{array}\right] + \left[\begin{array}{cc} 1 & -1 \\ 1 & 2 \\ \end{array}\right] = \left[\begin{array}{cc} 1+1 & 2-1 \\ 4+1 & 5+2 \\  \end{array}\right] = \left[\begin{array}{cc} 2 & 1 \\ 5 & 7 \\ \end{array}\right] .\]

This is achieved, by having a question in which simplification is off, and we define the question variables as follows.

    A:matrix([1,2],[4,5]);
    B:matrix([1,-1],[1,2]);
    C:apply(matrix,zip_with(lambda([l1,l2],zip_with("+",l1,l2)),args(A),args(B)));
    D:ev(C,simp);

Notice the use of `zip_with` which is not a core Maxima function, but is defined by STACK.
The above equation is then generated by the CASText

\[ @A@+@B@=@C@=@D@.\]

A similar procedure is needed for showing working when multiplying matrices.   Here we need to loop over the matrices, for square matrices we use the following.

    A:ev(rand(matrix([5,5],[5,5]))+matrix([2,2],[2,2]),simp);
    B:ev(rand(matrix([5,5],[5,5]))+matrix([2,2],[2,2]),simp);
    BT:transpose(B);
    C:zeromatrix (first(matrix_size(A)), second(matrix_size(A)));
    S:for a:1 thru first(matrix_size(A)) do for b:1 thru second(matrix_size(A)) do C[ev(a,simp),ev(b,simp)]:apply("+",zip_with("*",A[ev(a,simp)],BT[ev(b,simp)]));
    D:ev(C,simp);

Notice we need to simplify the arguments before we take indices of expressions.  This is one problem with `simp:false`.

For non-square matrices we can use this.

    A:ev(rand(matrix([5,5,5],[5,5,5]))+matrix([2,2,2],[2,2,2]),simp);
    B:transpose(ev(rand(matrix([5,5,5],[5,5,5]))+matrix([2,2,2],[2,2,2]),simp));
    TA:ev(A.B,simp);
    BT:transpose(B);
    C:zeromatrix (first(matrix_size(A)), second(matrix_size(B)));
    S:for a:1 thru first(matrix_size(A)) do for b:1 thru second(matrix_size(B)) do C[ev(a,simp),ev(b,simp)]:apply("+",zip_with("*",A[ev(a,simp)],BT[ev(b,simp)]));
    D:ev(C,simp);

Now it makes no sense to include the pointwise multiplication of elements as a possible wrong answer.

There must be a more elegant way to do this!

## Display of matrices ## {#matrixparens}

You can set the type of parentheses used to surround matrices in a number of ways.  Firstly, the admin user should set the site default in the qtype_stack options page.

For an individual question, the teacher can set the variable

    lxmchar:"(";
    
in any of the usual places, e.g. in the question variables.

To set the display of an individual matrix, `m` say, in CASText you can use

    @(lxmchar:"|", m)@ 

Since `lxmchar` is a global setting in Maxima, you will have to set it back when you next display a matrix.  Not ideal, but there we are.

Note, STACK only displays matrices with matching parentheses.  If you want something like
\[ f(x) = \left\{ \begin{array}{cc} 1, & x<0 \\ 0, & x\geq 0 \end{array}\right.\]
then you will have to display the matrix without parentheses and sort out the mismatching parentheses in the CASText at the level of display.

## Vectors ##

If you are trying to use the vector notation such as \(3i+4j\) you will probably want to redefine \(i\) to be an abstract symbol, not a complex number.
More information on this is given under [Numbers](Numbers.md).

Another way to do this is to create matrices as follows:

    ordergreat(i,j,k);
    p:matrix([-7],[2],[-3]);
    q:matrix([i],[j],[k]);

Now we can use the dot product to create the vector.  The STACK function `texboldatoms` prints all atomic variable names in bold.  

    v:texboldatoms(dotproduct(p,q))

If you turn the option "Multiplication sign" to none, this should display as
\[-7\,{\bf{i}}+2\,{\bf{j}}-3\,{\bf{k}}\]
Notice the use of the function `ordergreat`.  This can only be used once at the beginning of the question.


## See also

[Maxima reference topics](index.md#reference).
